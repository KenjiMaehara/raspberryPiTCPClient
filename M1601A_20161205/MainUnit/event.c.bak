/*
 * 
 *
 * 
 * 
 */

#include <avr/io.h>
#include <includes.h>
#include "port.h"
#include "env.h"
#include "event.h"

enum _SUB_STATE_
{
	DETECTION = 0,
	WAIT_RESET,	
	WAIT_RESET_TIMEOUT,
	
};

static u8 g_state;
static u8 sub_state;
static bool g_device_door[4];

void event_set_state(u8 state)
{
	if(g_state == SET && state == RESET)
	{
		if(sub_state == WAIT_RESET_TIMEOUT || sub_state == WAIT_RESET)
		{
			if(sub_state == WAIT_RESET_TIMEOUT)
			{
				set_hed_lmp_drv(false);
				set_hzd_lmp_drv(false);
				set_emg_relay_drv(false);
				
				rf_send_emg(false);
			}
		}
	}
	g_state = state;
}


u8 event_get_state(void)
{
	return g_state;	
}

bool event_get_door_open(void)
{
	if(get_right_door_switch() == true ||
		get_left_door_switch() == true)
		return true;
		
	return false;
}




void EventTask(void *p_arg)
{
	u32 Os_GetTime=0;
	bool toggle_led = false;
	bool toggle = false;

	g_state = RESET;
	sub_state = DETECTION;
	while(1)
	{
		switch(g_state)
		{
			case RESET:
				toggle_led = false;
				if(event_get_door_open() == true)
				{
					set_driver_led(true);
				}
				else
				{
					set_driver_led(false);
				}
				
				// Device D
				if(g_device_door[0] == true )
				{
					set_re_door_led(true);
				}
				else
				{
					set_re_door_led(false);
				}
				
				
				// Device E
				if(g_device_door[1] == true )
				{
					set_ri_door_led(true);
				}
				else
				{
					set_ri_door_led(false);
				}
				
				// Device F,G
				if(g_device_door[2] == true || g_device_door[3] == true)
				{
					set_cavin_led(true);
				}
				else
				{
					set_cavin_led(false);
				}
			
				break;
				
			case TEMP_RESET:
				toggle_led = true;
				//  점멸 
				
				//set_w_mod_led( );
			
				break;
				
			case SET:
				switch(sub_state)
				{
					case DETECTION:
						if(event_get_door_open() == true ||
							g_device_door[0] == true || g_device_door[1] == true || g_device_door[2] == true || g_device_door[3] == true )
						{
							if(get_right_door_switch() == true)
								Os_GetTime = OSTimeGet() + gEnv.driver.off_time * OS_TICKS_PER_SEC;
							else
								Os_GetTime = OSTimeGet() + gEnv.security.off_time * OS_TICKS_PER_SEC;
						
						
							// message start
					
							if(event_get_door_open() == true)
							{
								set_driver_led(true);
							}
										
							// Device D
							if(g_device_door[0] == true )
							{
								set_re_door_led(true);
							}
			
				
							// Device E
							if(g_device_door[1] == true )
							{
								set_ri_door_led(true);
							}
				
							// Device F,G
							if(g_device_door[2] == true || g_device_door[3] == true)
							{
								set_cavin_led(true);
							}
							toggle_led = true;
							sub_state = WAIT_RESET;
						}
						break;
					case WAIT_RESET:
						if(Os_GetTime <= OSTimeGet())
						{
							
							set_hed_lmp_drv(true);
							set_hzd_lmp_drv(true);
							set_emg_relay_drv(true);
							
							// message 
	
							
							// amp on
							set_mute_off(true);
							set_s_down(false);
							
							//
							rf_send_emg(true);
							sub_state = WAIT_RESET_TIMEOUT;

						}
						break;
					case WAIT_RESET_TIMEOUT:
						break;
				}
						
				break;
				
			case MAINTENCE:
			
				break;
		}
		
		if(toggle_led == true)
		{
			toggle ^= 0x01;
			set_w_mod_led(toggle);
			
		}
		
		OSTimeDlyHMSM(0,0,0,100);
	}
}

