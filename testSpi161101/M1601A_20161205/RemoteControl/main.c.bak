/*
 * 
 *
 * Created: 
 *  Author: 
 */ 

#include <avr/io.h>
#include <avr/interrupt.h>
#include <mytype.h>
#include "cc1100.h"

#include <util/delay.h>
#include "port.h"
#include "env.h"
#include "spi.h"


int btn_emg_count=-1;
int btn_open_count=-1;
int btn_rear_open_count=-1;
int btn_side_open_count=-1;
int btn_set_count=-1;
int btn_reset_count=-1;
u8 btn_emg,btn_open,btn_rear_open,btn_side_open,btn_set,btn_reset;
bool emg_state = false;
bool set_state = false;
u32 gMasterId;



void delay_us(u8 time_us)		/* time delay for us(1~255 us) for 32MHz */
{
	register unsigned char i;

	for(i = 0; i < time_us; i++)			// 4 cycles
	{ asm volatile("PUSH R0");			// 1 cycles
		asm volatile("NOP    ");			// 1 cycles
		asm volatile("POP  R0");			// 2 cycles
		asm volatile("PUSH R0");			// 1 cycles
		asm volatile("NOP    ");			// 1 cycles
		asm volatile("POP  R0");			// 2 cycles
		asm volatile("PUSH R0");			// 1 cycles
		asm volatile("NOP    ");			// 1 cycles
		asm volatile("POP  R0");			// 2 cycles
		asm volatile("PUSH R0");			// 1 cycles
		asm volatile("NOP    ");			// 1 cycles
		asm volatile("POP  R0");			// 2 cycles
		asm volatile("PUSH R0");			// 1 cycles
		asm volatile("NOP    ");			// 1 cycles
		asm volatile("POP  R0");			// 2 cycles
		asm volatile("PUSH R0");			// 1 cycles
		asm volatile("NOP    ");			// 1 cycles
		asm volatile("POP  R0");			// 2 cycles
		asm volatile("PUSH R0");			// 1 cycles
		asm volatile("NOP    ");			// 1 cycles
		asm volatile("POP  R0");			// 2 cycles = total 32 cycles
	}
}

void delay_ms(u16 time_ms)		/* time delay for ms(1~65535 ms) for 32MHz */
{
	register unsigned int i;

	for(i = 0; i < time_ms; i++)
	{ 
		delay_us(250);
		delay_us(250);
		delay_us(250);
		delay_us(250);
	}
}


void setClockTo32MHz() 
{
	CCP = CCP_IOREG_gc;              // disable register security for oscillator update
	OSC.CTRL = OSC_RC32MEN_bm;       // enable 32MHz oscillator
	while(!(OSC.STATUS & OSC_RC32MRDY_bm)); // wait for oscillator to be ready
	CCP = CCP_IOREG_gc;              // disable register security for clock update
	CLK.CTRL = CLK_SCLKSEL_RC32M_gc; // switch to 32MHz clock
}


u8 ReadSignatureByte(u16 Address)
{
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
	uint8_t Result;
	__asm__ ("lpm %0, Z\n" : "=r" (Result) : "z" (Address));
	//  __asm__ ("lpm \n  mov %0, r0 \n" : "=r" (Result) : "z" (Address) : "r0");
	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
	return Result;
}

u16 read_adc(void)
{
	u8 Waste;

	if ((ADCA.CTRLA & ADC_ENABLE_bm) == 0)
	{
		ADCA.CTRLA = ADC_ENABLE_bm ; // Enable the ADC
		ADCA.CTRLB |= (1<<4); // Signed Mode?  pos neg?
		//ADCA.CTRLB |= (1<<3); // Continius Mode
		ADCA.REFCTRL = 0; // Internal 1v ref
		ADCA.EVCTRL = 0 ; // no events
		//ADCA.EVCTRL = (5<<3); // ADC5,6,7selected events
		ADCA.PRESCALER = ADC_PRESCALER_DIV128_gc ;
		ADCA.CALL = ReadSignatureByte(0x20) ; //ADC Calibration Byte 0
		ADCA.CALH = ReadSignatureByte(0x21) ; //ADC Calibration Byte 1
		//ADCA.CALL = 0x00;		//test
		//ADCA.CALH = 0x0F;		//test
		_delay_ms(10);//OSTimeDlyHMSM(0,0,0,10); // Wait at least 25 clocks
	}
	ADCA.CH0.CTRL = ADC_CH_GAIN_1X_gc | 0x01 ; // Gain = 1, Single Ended
	//ADCA.CH0.CTRL = ADC_CH_GAIN_1X_gc | 0x10 ; // Gain = 1, Single Ended
	//ADCA.CH0.MUXCTRL = (0x07<<3);
	ADCA.CH0.MUXCTRL = (0x00<<3) ;
	//ADCA.CH0.MUXCTRL = (0x00<<3);
	ADCA.CH0.INTCTRL = 0 ; // No interrupt
	for(Waste = 0; Waste<2; Waste++)
	{
		ADCA.CH0.CTRL |= ADC_CH_START_bm; // Start conversion
		while (ADCA.INTFLAGS==0) ; // Wait for complete
		ADCA.INTFLAGS = ADCA.INTFLAGS ;
	}
	
	return ADCA.CH0RES ;
}


u16 temperature_get(void)
{
	u16 temp;
	
	temperature_test_enable();
	_delay_ms(100);

	//while(1);
	temp = read_adc();

	_delay_ms(100);

	temperature_test_disenable();

	return temp;
}




void set_freq(void)
{
	
	volatile u16	frq;
	volatile u8 	fr;
	volatile u16 	offset;
	volatile u16 	level;
	volatile u16 	temperature;
	

	//fr = 0x00;//get_freq();
	fr = ~get_freq()  & 0x0f;


	#if	0
	eeprom_read_block((void*)&gTele_env,(void*) 0x000,sizeof(tele_env_t));

	if(gTele_env.ctl_data.freq_add_sub == 0x80)
	{
		frq -= gTele_env.ctl_data.adj_freq;
	}
	else
	{
		frq += gTele_env.ctl_data.adj_freq;
	}

	temperature = temperature_get();

	if(gTele_env.ctl_data.temper_add_sub == 0x80)
	{
		temperature -= gTele_env.ctl_data.adj_temper;
	}
	else
	{
		temperature += gTele_env.ctl_data.adj_temper;
	}

	offset = 0x0339 - temperature;
	level = 13 - (offset / 0x0c);

	if(offset & 0x8000)
	{
		level = 13;
	}
	else if((offset / 0x0c)>13)
	{
		level = 0;
	}
	gLevel = level;

	frq += level_offset[5level];
	#endif



	
	frq = 0x66c0 + (fr * 0x003f);

	offset = 0x0339 - 0;
	
	level = 13 - (offset / 0x0c);
	

	if(offset & 0x8000)
	level = 13;
	else if((offset / 0x0c)>13)
	level = 0;
	//26867
	cc1101_set_freq(frq);
}



#if 1



u8 cc1101_tx(u8 * data , u8 length,u8 th)
{
	int i;

	cc1101_rtx_reg_set(0);
	cc1101_carrier_wave_setup();
	cc1100_cmd_idle();
	cc1100_cmd_calibrate();
	tx_fifo_write(data,length);
	
	cc1100_write_reg(CC1100_REG_MCSM1,0x00);
	cc1100_cfg_gdo0(0x09);



	cc1100_cfg_gdo0(CC1100_GDOx_SYNC_WORD);
	cc1100_cmd_tx();
	while(!get_gdoa());	//data send start
	while(get_gdoa());		//data send end
	
	//for(int i=0;i<4;i++)
	{
		//_delay_ms(500);	
	}

	
	return 1;
}

//#define WOR


ISR(PORTA_INT1_vect)
{


}

ISR(PORTC_INT1_vect)
{


}



#define sleep() __asm__ __volatile__ ("sleep")

u8 cc1101_rx(u8 * data,u8 * rssi, u8 * lqi)
{
	int cnt_wait_syn_ack=0;
	//int cnt_wait_syn_ack02=0;
	u8 length;
	u8 RX_STATUS = RX_FIFO_NONE;
	
	

#ifdef WOR
	cc1100_cfg_gdo0(0x24);

	PORTC.INT1MASK=0x04;
	PORTC.INTCTRL=0x0C;
	PORTA.INT1MASK=0x04;
	PORTA.INTCTRL=0x0C;
	
	cc1100_write_reg(CC1100_REG_WOREVT1, 0x13);
	//cc1100_write_reg(CC1100_REG_WOREVT0, 0xA0);
	cc1100_write_reg(CC1100_REG_WOREVT0, 0x87);	
	cc1100_write_reg(CC1100_REG_WORCTRL, 0x79);	
	
	cc1100_write_reg(CC1100_REG_MCSM0, 0x38);
	cc1100_write_reg(CC1100_REG_MCSM2, 0x01);
	
	
	cc1100_strobe_cmd(0x38);

	SLEEP_CTRL |= SLEEP_SMODE_PDOWN_gc;
	SLEEP_CTRL |= SLEEP_SEN_bm;
	
	sleep();
	
	PORTC.INT1MASK=0x00;
	PORTA.INT1MASK=0x00;
	
#endif 	

	cc1100_cmd_idle();
	set_freq();
	//check01 = cc1100_read_status(CC1100_REG_MARCSTATE);
	
	cc1101_rtx_reg_set(1);
	cc1101_carrier_wave_setup();
	cc1100_cfg_gdo0(CC1100_GDOx_SYNC_WORD);

	cc1100_cmd_idle();
	cc1100_cmd_flush_rx();
	cc1100_cmd_calibrate();
	cc1100_cmd_rx();
	
	//check02 = cc1100_read_status(CC1100_REG_MARCSTATE);
	while(get_gdoa() == false)
	{
		_delay_ms(1);
		if(++cnt_wait_syn_ack > 50)
		break;
	}
	
	//check03 = cc1100_read_status(CC1100_REG_MARCSTATE);
	
	cnt_wait_syn_ack = 0;
	//cnt_wait_syn_ack02 = 0;

	while(1)
	{
		if(get_gdoa()==true || RX_STATUS==RX_FIFO_MAKING || RX_STATUS==RX_FIFO_COMPLETE)
		{
			
			if(get_gdoa() == false || RX_STATUS==RX_FIFO_COMPLETE)
			{
				if((cc1100_status_crc_lqi() & 0x80))
				{
					length = rx_fifo_read(data,rssi,lqi);
					return length;
				}
				else
				{
					RX_STATUS=RX_FIFO_COMPLETE;
				}
			}
			else
			{
				RX_STATUS=RX_FIFO_MAKING;
			}
		}
		
		_delay_ms(1);
		if(++cnt_wait_syn_ack > 500)
		{
		
			break;
		}
	}
	return 0;
}


#endif


void cc1101_tx_carrier(void)
{

	cc1101_carrier_wave_setup();

	cc1100_cfg_txoff_mode(CC1100_TXOFF_MODE_STAY_TX);
	cc1100_cfg_manchester_en(CC1100_MANCHESTER_DISABLE);
	cc1100_write_reg(CC1100_REG_MDMCFG3,0x33);
	cc1100_cfg_mod_format(CC1100_MODULATION_ASK);
	cc1100_write_reg(CC1100_REG_FREND0,0x10);
	cc1100_cfg_gdo0(CC1100_GDOx_CLK_XOSC_1);

	/* IDLE */
	cc1100_cmd_idle();
	/* MANCAL*/
	cc1100_cmd_calibrate();
	/* FS WAKEUP */
	cc1100_cmd_flush_tx();

	cc1100_cfg_gdo0(0x0e);
	//carrier_sense();

	cc1100_cmd_tx();
}


void temperature_test_enable(void)
{
	cc1100_cmd_idle();
	cc1100_write_reg(CC1100_REG_PTEST,0xBF);
	cc1100_cfg_gdo0(0x80);
}


void temperature_test_disenable(void)
{
	cc1100_cfg_gdo0(0x3F);
	cc1100_write_reg(CC1100_REG_PTEST,0x7F);
}


void timer_setup(void)
{
	/* Set up Timer/Counter 0 to work from CPUCLK/64, with period 10000 and
	 * enable overflow interrupt.
	 */
	TCC0.PER = 250;
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_DIV64_gc;
	TCC0.INTCTRLA = ( TCC0.INTCTRLA & ~TC0_OVFINTLVL_gm ) | TC_OVFINTLVL_MED_gc;
}


bool buz_toggle = false;
bool toggle = false;
int timer_1S_count = 0;
int send_timer=-1;
volatile bool gBuzzer;

ISR(TCC0_OVF_vect)
{
	if(gBuzzer == true)
	{
		buz_toggle ^= 0x01;
		set_buzzer(buz_toggle);
	}
	else
	{
		set_buzzer(0);
	}
	
	if(send_timer > -1)
	{
		send_timer++;
		
	}
	

	
	if(timer_1S_count++ > 1000)
	{
		timer_1S_count  = 0;
		
		if(btn_emg_count > -1)
			btn_emg_count++;
			
		if(btn_open_count > -1)
			btn_open_count++;
		if(btn_rear_open_count > -1)
		btn_rear_open_count++;
		if(btn_side_open_count > -1)
		btn_side_open_count++;
		if(btn_set_count > -1)
		btn_set_count++;
		if(btn_reset_count > -1)
		btn_reset_count++;
	}
}



void button_check(void)
{
	// switch check
	if(btn_emg != get_emergency_button())
	{
		if(get_emergency_button() == true && emg_state == false)
		{
			btn_emg_count=0;
			buzzer_on(true);
		}
		else if(get_emergency_button() == true && emg_state == true)
		{
			btn_emg_count=0;
			buzzer_on(true);
		}
		else if(get_emergency_button() == false)
		{
			buzzer_on(false);
		}
		
		btn_emg = get_emergency_button();
	}
	
	if(btn_open != get_cab_unlocked())
	{
		if(get_cab_unlocked() == true)
		{
			btn_open_count=0;
			buzzer_on(true);
		}
		else
		{
			buzzer_on(false);
		}
		btn_open = get_cab_unlocked();
	}
	
	if(btn_rear_open != get_rear_door_unlocked())
	{
		bool door = get_rear_door_unlocked();
		
		if(door == true)
		{
			btn_rear_open_count=0;
			buzzer_on(true);
		}
		else
		{
			gBuzzer = false;
		}
		btn_rear_open = door;
	}
	
	if(btn_side_open != get_side_door_unlocked())
	{
		if(get_side_door_unlocked() == true)
		{
			btn_side_open_count=0;
			buzzer_on(true);
		}
		else
		{
			gBuzzer = false;
		}
		btn_side_open = get_side_door_unlocked();
	}
	
	if(btn_set != get_security_set())
	{
		if(get_security_set() == true)
		{
			btn_set_count=0;
			buzzer_on(true);
		}
		else
		{
			gBuzzer = false;
		}
		btn_set = get_security_set();
	}
	
	if(btn_reset != get_security_reset())
	{
		if(get_security_reset() == true)
		{
			btn_reset_count=0;
			buzzer_on(true);
		}
		else
		{
			gBuzzer = false;
		}
		btn_reset = get_security_reset();
	}	
}


void buzzer_error(void)
{
	
	
	
}

volatile void buzzer_on(bool buz)
{
	gBuzzer = buz;
}

bool emg_send(u8 emg)
{
	int length;
	remote_emg_t temg;
	u8 rssi,lqi;
	
	
	temg.hdr.slave_id = gEnv.id;
	temg.hdr.payload = PAYLOAD_REMOCON_EMG;
	temg.emg = emg;

	set_freq();
	cc1101_tx(&temg,sizeof(emg_t),1);
	
	send_timer = 0;
	
	while(1)
	{
		
		set_freq();
		length = cc1101_rx((u8 *)&temg,&rssi,&lqi);
		if(length > 0 )
		{
			if(temg.hdr.slave_id == gEnv.id && temg.hdr.payload == PAYLOAD_REMOCON_EMG)
			{
				send_timer = -1;
				return true;
			}
		}
		cc1100_cmd_idle();
		
		if(send_timer > 1000)
		{
			send_timer = -1;
			break;
		}
		// need timeout;
	}
	
	
	return false;
}


void emg_set_process(void)
{
	// buzzer off;
	emg_state = true;
	set_emg_led(true);
	set_voice(5);
	
	emg_send(true);
	
}


void emg_reset_process(void)
{
	// buzzer off;
	emg_state = false;
	set_emg_led(false);
	emg_send(false);
}


bool door_open_send(u8 door)
{
	int length;
	door_open_t tdoor;
	u8 rssi,lqi;
	
	
	tdoor.hdr.slave_id = gEnv.id;
	tdoor.hdr.payload = PAYLOAD_DOOR_OPEN_CMD;
	tdoor.door = door;
	tdoor.open = 1;
	
	set_freq();
	cc1101_tx(&tdoor,sizeof(door_open_t),1);
	
	send_timer = 0;	
	while(1)
	{
		
		set_freq();
		length = cc1101_rx((u8 *)&tdoor,&rssi,&lqi);
		if(length > 0 )
		{
			if(tdoor.hdr.slave_id == gEnv.id && tdoor.hdr.payload == PAYLOAD_DOOR_OPEN_CMD)
			{
				send_timer = -1;
				return true;
			}
		}
		cc1100_cmd_idle();
		
		if(send_timer > 2000)
		{
			send_timer = -1;
			break;
		}
	}
	
	
	return false;
}

void emg_driver_door_process(void)
{
	if(door_open_send(1) == false)
	{
		set_voice(8);
		buzzer_error();
		return;		
	}
	set_voice(3);

}


void emg_rear_door_process(void)
{
	if(door_open_send(3) == false)
	{
		set_voice(8);
		buzzer_error();
		return;
	}
	set_voice(3);

}


void emg_side_door_process(void)
{
	if(door_open_send(4) == false)
	{
		set_voice(8);
		buzzer_error();
		return;
	}
	set_voice(3);

}


bool set_send(u8 set)
{
	u8 rssi,lqi;
	int length;
	set_cmd_t lset;
	
	lset.hdr.slave_id = gEnv.id;
	lset.hdr.payload = PAYLOAD_SET_CMD;
	lset.set = set;

	set_freq();
	cc1101_tx(&lset,sizeof(set_cmd_t),1);

	send_timer = 0;	
	
	while(1)
	{
		
		set_freq();
		length = cc1101_rx((u8 *)&lset,&rssi,&lqi);
		if(length > 0 )
		{
			if(lset.hdr.slave_id == gEnv.id && lset.hdr.payload == PAYLOAD_SET_CMD)
			{
				send_timer = -1;
				return true;
			}
		}
		cc1100_cmd_idle();
		
		if(send_timer > 1000)
		{
			send_timer = -1;
			break;
		}
	}
	
	
	return false;
}

void set_process(u8 set)
{
	if(set_send(set) == false)
	{
		set_voice(8);
		buzzer_error();
		return;
	}
	
	//emg_state = set;
	set_security_mode_led(set);
	if(set== true)
		set_voice(1);
	else	
		set_voice(2);

	
}


void button_process(void)
{
	if(btn_emg_count > 0)
	{
		if(emg_state == false && (btn_emg_count > gEnv.emg_btn_set))
		{ 
			// emg_set
			set_emg_button_led(true);			
			emg_set_process();
			btn_emg_count = -1;
			
		}
		else if(emg_state == true && (btn_emg_count > gEnv.emg_btn_reset))
		{
			// emg_reset
			
			btn_emg_count = -1;
			set_emg_button_led(false);
			emg_reset_process();
		}
	}
	else if(btn_open_count > gEnv.set_time)
	{
		// driver door open
		btn_open_count = -1;
		emg_driver_door_process();
		
	}
	else if(btn_rear_open_count > gEnv.set_time)
	{
		// driver door open
		btn_rear_open_count = -1;
		emg_rear_door_process();
		
	}
	else if(btn_side_open_count > gEnv.set_time)
	{
		// driver door open
		btn_side_open_count = -1;
		emg_side_door_process();
		
	}
	else if(btn_set_count > gEnv.set_time)
	{
		// driver door open
		btn_set_count = -1;
		set_process(true);
		
		
	}
	else if(btn_reset_count > gEnv.reset_time)
	{
		// driver door open
		btn_reset_count = -1;
		set_process(false);
		buzzer_on(false);
	}	
}


/*
sync ack
*/

void sync_ack(void)
{
	sync_t sync;
	
	sync.hdr.master_id = gMasterId;
	sync.hdr.slave_id = gEnv.id;
	sync.hdr.payload = PAYLOAD_SYNC;
	
	//_delay_ms(300);
	set_freq();
	cc1101_tx(&sync,sizeof(sync_t),1);
}



/*
set_state_ack
*/

void set_state_ack(void)
{
	set_t set;
	
	set.hdr.master_id = gMasterId;
	set.hdr.slave_id = gEnv.id;
	set.hdr.payload = SET_STATE;
	
	set_freq();
	cc1101_tx(&set,sizeof(set_t),1);
}



/*
set_state_ack
*/

void emg_ack(void)
{
	emg_t emg;
	
	emg.hdr.master_id = gMasterId;
	emg.hdr.slave_id = gEnv.id;
	emg.hdr.payload = PAYLOAD_EMG;
	
	set_freq();
	cc1101_tx(&emg,sizeof(emg_t),1);
	
}


/*
setup_ack
*/

void setup_ack(u32 id)
{
	setup_t setup;
	
	setup.hdr.master_id = gMasterId;
	setup.hdr.slave_id = id;
	setup.hdr.payload = PAYLOAD_SETUP_ID;
	//_delay_ms(300);
	set_freq();
	cc1101_tx(&setup,sizeof(setup_t),1);
}




void test_wave_mode(void)
{
	int i;
	int old,new;


	cc1100_cfg_gdo0(CC1100_GDOx_SYNC_WORD);
	cc1101_init_reg();
	cc1101_8PATABLE_write_reg();
	cc1100_cfg_gdo0(CC1100_GDOx_SYNC_WORD);


	while(1)
	{

		cc1100_cmd_idle();

		delay_ms(100);


		cc1101_rtx_reg_set(0); // tx
		cc1100_write_reg(CC1100_REG_PKTCTRL0,0x22);	//random TX mode
		cc1101_carrier_wave_setup();
		cc1100_cmd_idle();
		cc1100_cmd_calibrate();
		cc1100_cmd_tx();



		
		delay_ms(3000);
		cc1100_cmd_idle();
		delay_ms(3000);

	}
}


void comm_led(void)
{
	int i;
	
	
	for(i = 0 ; i < 1 ; i++)
	{
		set_communication_led(1);
		_delay_ms(50);
		set_communication_led(0);
		_delay_ms(50);
	}
}

int g_length;
u8 gtemp;
packet_t gPacket;
u16 adc_value;

int main(void)
{
	u8 rssi,lqi;
	int length;
	
	
	setClockTo32MHz();	
	
	port_init();
	spi_init();
	env_init();
	timer_setup();
	TCC0_INTCTRLA = 0x03;				// enable OVF interrupt with high level
	
	
	set_voice(0xff);
	
	gEnv.emg_btn_set = 4;
	gEnv.emg_btn_reset = 5;
	gEnv.set_time = 2;
	gEnvDown.emg_btn_set = 4;
	gEnvDown.emg_btn_reset = 5;
	gEnvDown.set_time = 2;
	
	cc1100_init(delay_ms,spi_write_single,spi_read_single,spi_write,spi_read,spi_select,spi_deselect,spi_read_somi);
	cc1101_init_reg();
	cc1101_8PATABLE_write_reg();
	
	
	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;
	sei();	
	

	btn_emg = get_emergency_button();
	btn_open = get_cab_unlocked();
	btn_rear_open = get_rear_door_unlocked();
	btn_side_open = get_side_door_unlocked();
	btn_set = get_security_set();
	btn_reset = get_security_reset();

#if 0
	while(1)
	{
		
			//	sync_ack();
		set_communication_led(1);
		_delay_ms(100);
		set_communication_led(0);
		_delay_ms(100);

	}
#endif	
    while(1)
    {
		set_freq();
#if 0		
		test_wave_mode();
		
		continue;
#endif 		
		g_length = cc1101_rx((u8 *)&gPacket,&rssi,&lqi);

		if(g_length == sizeof(packet_t))
		{
			gMasterId = gPacket.hdr.master_id;
			gtemp = ~get_dly() & 0x0c;
			if((gtemp) == 0x00)
			{
				if(gPacket.hdr.slave_id == 0xffffffff && gPacket.hdr.payload == PAYLOAD_SETUP_ID)
				{
					
					setup_t * setup;
					int kk;
					

					comm_led();
					setup = (set_t *)	&gPacket;

					setup_ack(setup->id);
					
					gEnv.id = setup->id;
					env_save(&gEnv);
					
					for(kk = 0 ; kk < 10 ; kk++)
					{
						set_emg_led(1);
						_delay_ms(100);
						set_emg_led(0);
						_delay_ms(100);
					}
				}
			}
			else if(gPacket.hdr.slave_id == gEnv.id)
			{
				switch(gPacket.hdr.payload)
				{
					case PAYLOAD_SYNC:
						sync_ack();
						
						gEnv.emg_btn_set = gPacket.payload[1];
						gEnv.emg_btn_reset = gPacket.payload[2];
						gEnv.set_time=gPacket.payload[3];
						gEnvDown.emg_btn_set = gPacket.payload[1];
						gEnvDown.emg_btn_reset = gPacket.payload[2];
						gEnvDown.set_time=gPacket.payload[3];
						set_state = 0 ;
						emg_state = 0;

						break;
					case SET_STATE:
					{
						set_t * set;
						
						set_state_ack();

						set = (set_t *)	&gPacket;
						
						
						if(set_state != set->set)
						{
							set_state = set->set ;
							set_security_mode_led(set->set);
						
							if(set->set == true)
							set_voice(1);
							else
							set_voice(2);
							
						}
						
						break;
					}
					case PAYLOAD_EMG:
					{
						emg_t * emg;
						
						emg_ack();

						emg = (emg_t *)	&gPacket;
						
						
						
						emg_state = emg->emg ;
						set_emg_led(emg_state);
						
						if(emg_state == true)
						{
							set_voice(1);

							// 
						}
						else
						{
							// buzzer 3 sec
							
						}
					}
					
				}
				comm_led();

			} 
		}
		cc1100_cmd_idle();
		
		if(get_dly() & 0x01)
		{
			gEnv.emg_btn_set = gEnvDown.emg_btn_set;
			gEnv.emg_btn_reset = gEnvDown.emg_btn_reset;
			gEnv.set_time = gEnvDown.set_time;
		}
		else
		{
			gEnv.emg_btn_set = 4;
			gEnv.emg_btn_reset = 5;
			gEnv.set_time = 2;
		}
		
		
		button_check();
		
		
		button_process();

    }
}