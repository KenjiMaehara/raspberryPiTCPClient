/*
 * 
 *
 * 
 * 
 */

#include <avr/io.h>
#include <includes.h>
#include "port.h"
#include "Oper.h"
#include "env.h"
#include "event.h"
#include "rf_task.h"


OS_EVENT *      oper_wait;



oper_t		gOper[MAX_OPER];


bool door_check(void);
static bool emg_state = false;
static bool car_check = false;
static int	car_check_count=0;
static u32 Os_GetTime=0;



bool oper_get_emg_state(void)
{
	return emg_state;
}



void oper_insert(u8 oper,u8 data)
{
	int i;
	oper_t * pOper= NULL;
	
	for(i = 0 ; i < MAX_OPER ; i++)
	{
		if(gOper[i].used == 0)
		{
			gOper[i].used = 1;
			gOper[i].data = data;
			gOper[i].oper = oper;
			pOper = &gOper[i];
			break;			
			
		}
	}
	
	if(oper != NULL)
	{
		
		for(i = 0 ; i < 50 ; i++)
		{
			if(OSMboxPost(oper_wait, (void *)pOper) == OS_ERR_MBOX_FULL)
			{
				OSTimeDlyHMSM(0,0,1,0);
			}
			else
			{
				break;
			}
		}
	}
}


void operation_set(void)
{
	// check state
	if(event_get_state() == SET 
	  || event_get_state() == TEMP_RESET)
	 {
		 
		 // message
		SoundPlay(28);
		 return;
	 }
	 else if(event_get_state() == MAINTENCE)
	 {
		 return;
		 
	 }
	 
	 // display led
	set_re_door_led(false);
	set_ri_door_led(false);
	set_se_door_led(false);
	set_si_door_led(false);
	//set_driver_led(false);
	set_cavin_led(false);
	set_right_door_led(true);
	set_side_door_led(true);


	// door error check
	
	if(get_right_door_switch() == true
	|| get_left_door_switch() == true)
	{
		

		// error message
		SoundPlay(23);
		return ;
	}
	
	set_cel_motor_drv(false);
	set_d_mod_led(false);
	set_w_mod_led(true);
	
	

	event_set_state(SET);
	
	// set messsage
	
	rf_send_state(1); // set state
	
	
	set_audio_half(false);
	
	SoundPlay(21);
}


void operation_reset(void)
{
	
	if(event_get_state() == RESET)
	{
		
		// message
		SoundPlay(29);
		return;
	}
	else if(event_get_state() == MAINTENCE)
	{
		return;
		
	}
	
	set_cel_motor_drv(false);
	set_d_mod_led(false);
	//set_w_mod_led(true);
	set_w_mod_led(false);
	
	event_set_state(RESET);  
	// set messsage
	
	rf_send_state(RESET);
	SoundPlay(22);
	
}

void operation_emg(void)
{
	emg_state = true;
	set_audio_half(false);

	// emg message
	SoundPlay(25);	
	
	// amp on
	set_mute_off(true);
	set_s_down(false);
	
	
	// emg mode 2
	
	set_hed_lmp_drv(true);
	set_hzd_lmp_drv(true);
	set_emg_relay_drv(true);
	
	rf_send_emg(true);
}

void operation_emg_reset(void)
{
	emg_state = false;
	
	// amp on
	set_mute_off(false);
	set_s_down(true);
	
	
	// emg mode 2 off
	set_hed_lmp_drv(false);
	set_hzd_lmp_drv(false);
	set_emg_relay_drv(false);
	
	rf_send_emg(false);
}

void operation_audio(u8 oper)
{
	if(oper == true)
	{
		set_audio_half(false);

	}
	else
	{
		set_audio_half(true);
	}
}

void operation_engin_start(void)
{
	// check state
	if(event_get_state() == SET
	|| event_get_state() == TEMP_RESET)
	{
		
		set_cel_motor_drv(false);
		// message
		return;
	}
	else if(event_get_state() == MAINTENCE)
	{
		return;
		
	}

	// door error check
	if(get_right_door_switch() == true	|| get_left_door_switch() == true
	|| gDoorStatus[0] == true || gDoorStatus[1] == true || gDoorStatus[2] == true || gDoorStatus[3] == true
	|| gDoorStatus[4] == true || gDoorStatus[5] == true || gDoorStatus[6] == true || gDoorStatus[7] == true
	|| gDoorLock[0] == false || gDoorLock[1] == false || gDoorLock[2] == false || gDoorLock[3] == false)
	{
		
		set_cel_motor_drv(false);
		
		SoundPlay(31);	
	
		// amp on
		set_mute_off(true);
		set_s_down(false);
		return ;
	}
	
	set_cel_motor_drv(true);
	
}

void operation_service(void)
{
	
	event_set_state(MAINTENCE);


	// display led
	set_t_mod_led(true);
	set_d_mod_led(false);
	set_w_mod_led(false);
	
	set_cel_motor_drv(true);
	
	SoundPlay(32);
	
	while(get_ekyp_chek() == true)
	{
		
		OSTimeDlyHMSM(0,0,0,50);
	}
	
	
	set_t_mod_led(false);
	set_cel_motor_drv(false);
	event_set_state(RESET);
	
}


void operation_door(u8 door)
{
 	u32 Os_GetTime=0;
	bool timeout = false;
	 
	u8 open_count_right=0;
	u8 right_new,right_old;
	u8 open_count_left=0;
	u8 left_new,left_old;
	//u8 temp_g_state; 
	 
	 
	temp_g_state = event_get_state();
	
	// check state
	if(event_get_state() == SET
	|| event_get_state() == TEMP_RESET)
	{

		event_set_state(TEMP_RESET);
	}
	else if(event_get_state() == MAINTENCE)
	{
		return;
		
	}	
	
	if(door == 1)
	{
		set_driver_door_unlock(true);
	}
	else 
		set_security_door_unlock(true);
	
	SoundPlay(17);

	
	if(door == 1)
		Os_GetTime = OSTimeGet() + (u32)gEnv.driver.on_time * (u32)OS_TICKS_PER_SEC;
	else
		Os_GetTime = OSTimeGet() + (u32)gEnv.security.on_time * (u32)OS_TICKS_PER_SEC;
	
	while(1)
	{
		if(door == 1)
		{
			if(get_right_door_switch() == true)
			{
				break;
			}
		}
		else
		{
			if(get_left_door_switch() == true)
			{
				break;
			}
		}
		

		if(Os_GetTime < OSTimeGet())
		{
			timeout = true;
			break;
		}
		
		OSTimeDlyHMSM(0,0,0,100);
	}
	
	if(timeout == false)
	{
		

		if(door ==1 )
			set_driver_door_unlock(false);
		else
			set_security_door_unlock(false);
		
	
		set_driver_led(true);

		if(door == 1)
			Os_GetTime = OSTimeGet() + ((u32)gEnv.driver.off_time ) * (u32)OS_TICKS_PER_SEC;
		else
			Os_GetTime = OSTimeGet() + ((u32)gEnv.security.off_time) * (u32)OS_TICKS_PER_SEC;


		while(1)
		{
			if(door == 1)
			{
				if(get_right_door_switch() == false)
				{
					break;
				}
			}
			else
			{
				if(get_left_door_switch() == false)
				{
					break;
				}
			}
		
			if(Os_GetTime <= OSTimeGet())
			{
				break;
			}
		
		
			OSTimeDlyHMSM(0,0,0,100);
		}
	}


	if(door ==1 )
		set_driver_door_lock(false);
	else
		set_security_door_lock(false);


	if(temp_g_state == RESET)
	{
		event_set_state(RESET);
	}
	else
	{
		event_set_state(SET);
	}
}

	

// key f,g door
void operation_rf_door(u8 door)
{
	u32 id;
	int count;
	
	temp_g_state = event_get_state();

	if(event_get_state() == MAINTENCE)
	{
		return;
		
	}
	
	if(door == 3 && gEnv.use.cabin_right == false
	|| door == 4 && gEnv.use.cabin_left == false)
	{
		// buzzer;
		return;
	}
	
	id = door == 3 ? gEnv.id.cabin_right : gEnv.id.cabin_left;
	
	// rf_door_open_oper
	if(rf_door_open_oper(id) == false)
	{
		return false;
	}
	
	
	// check state
	if(event_get_state() == SET
	|| event_get_state() == TEMP_RESET)
	{

		event_set_state(TEMP_RESET);
	}
	set_cavin_led(true);

}


// remocon d,e door 
void oeration_rf_de_door(u8 door)
{
	u32 id;
	int count;
	
	 
	temp_g_state = event_get_state();
	 
	// check state
	if(event_get_state() == SET
	|| event_get_state() == TEMP_RESET)
	{

		event_set_state(TEMP_RESET);
	}
	else if(event_get_state() == MAINTENCE)
	{
		return;
		 
	}
	
	if(door == 3 && gEnv.use.b_door == false
	|| door == 4 && gEnv.use.s_door == false)
	{
		// buzzer;
		return;
	}
	
	id = (door == 3) ? gEnv.id.b_door : gEnv.id.s_door;
	
	rf_door_open_oper(id);
	
	#if 0
	// rf_door_open_oper
	if(rf_door_open_oper(id) == false)
	{
		return ;
	}
	#endif 
	
}


// remocon d,e door
void operation_check(void)
{
	u32 id;
	int count;
	
	
	if(car_check == true)
		return;
		
	set_car_check(true);
	SoundPlay(30);
	car_check = true;	
	Os_GetTime = OSTimeGet() + ((u32)60 * OS_TICKS_PER_SEC);
}


void OperTask(void *p_arg)
{
	oper_t * oper;
	u8 err;

	memset(&gOper,0,sizeof(oper_t) * MAX_OPER);
    oper_wait = OSMboxCreate((void *)0);


	while(1)
	{
        oper = (oper_t *)OSMboxPend(oper_wait, 1000, &err);
		

		if(err != 0)
		{
			if(car_check == true)
			{
				if(Os_GetTime <=  OSTimeGet())
				{
					car_check = false;
					set_car_check(false);
				}
				
			}
			continue;
		}
		
				
		switch(oper->oper)
		{
			case OPER_SET:
				operation_set();
				break;

			case OPER_RESET:
				operation_reset();
				break;

			case OPER_EMG:
				operation_emg();
				break;

			case OPER_EMG_RESET:
				operation_emg_reset();
				break;

			case OPER_AUDIO_PLUS:
			case OPER_AUDIO_MINUS:
				operation_audio(oper->oper);
				break;
			
			case OPER_ENG_START:
				operation_engin_start();
				break;
			
			case OPER_SERVICE:
				operation_service();
				break;
				
			case OPER_DOOR:
				if(oper->data == 1 || oper->data == 2)
				{
					operation_door(oper->data);
				}
				else if(oper->data == 3 || oper->data == 4)
				{
					operation_rf_door(oper->data);
				}
				else if(oper->data == 0)
				{
					operation_door(1);
					operation_door(2);
					
					operation_rf_door(3);
					operation_rf_door(4);
					
				}
				break;
			
			case OPER_RF_DOOR:
				set_hzd_lmp_drv(false);
				OSTimeDlyHMSM(0,0,0,200);
				set_hzd_lmp_drv(true);
				OSTimeDlyHMSM(0,0,0,200);
				set_hzd_lmp_drv(false);
				
				if(oper->data == 1 || oper->data == 2)
				{
					operation_door(oper->data);
				}
				else if(oper->data == 3 || oper->data == 4)
				{
					
					oeration_rf_de_door(oper->data);
				}
				break;
			case OPER_RF_SET:
				set_hzd_lmp_drv(false);
				OSTimeDlyHMSM(0,0,0,200);
				set_hzd_lmp_drv(true);
				OSTimeDlyHMSM(0,0,0,200);
				set_hzd_lmp_drv(false);
				operation_set();
				break;

			case OPER_RF_RESET:
				set_hzd_lmp_drv(false);
				OSTimeDlyHMSM(0,0,0,200);
				set_hzd_lmp_drv(true);
				OSTimeDlyHMSM(0,0,0,200);
				set_hzd_lmp_drv(false);
				operation_reset();
				break;
			case OPER_REMOCON_EMG:
			
				if(oper->data == 1)
				{
					set_hed_lmp_drv(true);
					set_hzd_lmp_drv(true);					
					set_emg_relay_drv(true);
					
					// emg message
					SoundPlay(25);	
	
					// amp on
					set_mute_off(true);
					set_s_down(false);
	
	
					// emg mode 2
	
					set_hed_lmp_drv(true);
					set_hzd_lmp_drv(true);
					set_emg_relay_drv(true);
	
					rf_send_emg(true);
					
				}
				else
				{
					// amp on
					set_mute_off(false);
					set_s_down(true);
	
	
					// emg mode 2 off
					set_hed_lmp_drv(false);
					set_hzd_lmp_drv(false);
					set_emg_relay_drv(false);
	
					rf_send_emg(false);					
				}

			
				break;	
			case OPER_CHECK:
				operation_check();
				break;
			
		}
		
		oper->used = 0;
	}
}



bool door_check(void)
{
	return true;
}