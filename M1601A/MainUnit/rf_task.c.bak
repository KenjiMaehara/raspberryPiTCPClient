/*
 * 
 *
 * 
 * 
 */

#include <avr/io.h>
#include <includes.h>
#include "port.h"
#include "cc1100.h"
#include "mytype.h"
#include "Oper.h"
#include "rf_task.h"
#include "env.h"
#include "menu.h"

fifo_t gfifo;

#define RF_TIME_OUT 2

OS_EVENT *  rf_lock_event=NULL;

void rf_lock(void)
{
	u8 err;
	if(rf_lock_event == NULL)
	{
		rf_lock_event = OSSemCreate(1);
	}
	OSSemPend(rf_lock_event, 0, &err);
}


void rf_unlock(void)
{
	OSSemPost(rf_lock_event);
}

u8 ReadSignatureByte(u16 Address)
{
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
	uint8_t Result;
	__asm__ ("lpm %0, Z\n" : "=r" (Result) : "z" (Address));
	//  __asm__ ("lpm \n  mov %0, r0 \n" : "=r" (Result) : "z" (Address) : "r0");
	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
	return Result;
}

u16 read_adc(void)
{
	u8 Waste;

	if ((ADCA.CTRLA & ADC_ENABLE_bm) == 0)
	{
		ADCA.CTRLA = ADC_ENABLE_bm ; // Enable the ADC
		ADCA.CTRLB |= (1<<4); // Signed Mode?  pos neg?  
		//ADCA.CTRLB |= (1<<3); // Continius Mode
		ADCA.REFCTRL = 0; // Internal 1v ref
		ADCA.EVCTRL = 0 ; // no events
		//ADCA.EVCTRL = (5<<3); // ADC5,6,7selected events
		ADCA.PRESCALER = ADC_PRESCALER_DIV128_gc ;
		ADCA.CALL = ReadSignatureByte(0x20) ; //ADC Calibration Byte 0
		ADCA.CALH = ReadSignatureByte(0x21) ; //ADC Calibration Byte 1
		//ADCA.CALL = 0x00;		//test
		//ADCA.CALH = 0x0F;		//test
		OSTimeDlyHMSM(0,0,0,10); // Wait at least 25 clocks
	}
	ADCA.CH0.CTRL = ADC_CH_GAIN_1X_gc | 0x01 ; // Gain = 1, Single Ended
	//ADCA.CH0.CTRL = ADC_CH_GAIN_1X_gc | 0x10 ; // Gain = 1, Single Ended
	//ADCA.CH0.MUXCTRL = (0x07<<3);
	ADCA.CH0.MUXCTRL = (0x05<<3);
	//ADCA.CH0.MUXCTRL = (0x00<<3);
	ADCA.CH0.INTCTRL = 0 ; // No interrupt
	for(Waste = 0; Waste<2; Waste++)
	{
		ADCA.CH0.CTRL |= ADC_CH_START_bm; // Start conversion
		while (ADCA.INTFLAGS==0) ; // Wait for complete
		ADCA.INTFLAGS = ADCA.INTFLAGS ;
	}
	
	return ADCA.CH0RES ;
}


u16 temperature_get(void)
{
	u16 temp;
	
	temperature_test_enable();

	OSTimeDlyHMSM(0,0,0,100); // Wait 100msec

	//while(1);
	temp = read_adc();

	OSTimeDlyHMSM(0,0,0,100); // Wait 100msec

	temperature_test_disenable();

	return temp;
}




void set_freq(void)
{
	
	volatile u16	frq;
	volatile int 	fr;
	volatile u16 	offset;
	volatile u16 	level;
	volatile u16 	temperature;
	

	//fr = 0x00;//get_freq();
	fr = ~get_freq();


	#if	0
	eeprom_read_block((void*)&gTele_env,(void*) 0x000,sizeof(tele_env_t));

	if(gTele_env.ctl_data.freq_add_sub == 0x80)
	{
		frq -= gTele_env.ctl_data.adj_freq;	
	}
	else
	{
		frq += gTele_env.ctl_data.adj_freq;		
	}

	temperature = temperature_get();

	if(gTele_env.ctl_data.temper_add_sub == 0x80)
	{
		temperature -= gTele_env.ctl_data.adj_temper;		
	}
	else
	{
		temperature += gTele_env.ctl_data.adj_temper;	
	}

	offset = 0x0339 - temperature;
	level = 13 - (offset / 0x0c);

	if(offset & 0x8000)
	{
		level = 13;		
	}
	else if((offset / 0x0c)>13)
	{
		level = 0;		
	}
	gLevel = level;

	frq += level_offset[level];
	#endif




	
	frq = 0x68fc + 430 + (fr * 0x003f);
	frq -= 0x10;
	offset = 0x0339 - 0;
	
	level = 13 - (offset / 0x0c);
	

	if(offset & 0x8000)
		level = 13;
	else if((offset / 0x0c)>13)
		level = 0;
		
	cc1101_set_freq(frq);
}



#if 1

u8 check01,check02,check03,check04,check05,check06;

u8 cc1101_tx(u8 * data , u8 length,u8 th)
{
	int i;

	check01 = cc1100_read_status(CC1100_REG_MARCSTATE);

	cc1101_rtx_reg_set(0);
	cc1101_carrier_wave_setup();
	cc1100_cmd_idle();
	cc1100_cmd_calibrate();
	tx_fifo_write(data,length);
	
	cc1100_write_reg(CC1100_REG_MCSM1,0x00);
	cc1100_cfg_gdo0(0x09);

	check02 = cc1100_read_status(CC1100_REG_MARCSTATE);


	cc1100_cfg_gdo0(CC1100_GDOx_SYNC_WORD);
	cc1100_cmd_tx();
	check03 = cc1100_read_status(CC1100_REG_MARCSTATE);
	while(!get_gdoa());	//data send start
	check04 = cc1100_read_status(CC1100_REG_MARCSTATE);
	while(get_gdoa())		//data send end
	{
		check05 = cc1100_read_status(CC1100_REG_MARCSTATE);			
	}

	OSTimeDlyHMSM(0,0,0,500);
	check06 = cc1100_read_status(CC1100_REG_MARCSTATE);	

	return 1;
}


u8 cc1101_rx(u8 * data,u8 * rssi, u8 * lqi)
{
	u8 cnt_wait_syn_ack=0;
	u8 length;

	cc1101_rtx_reg_set(1);
	cc1101_carrier_wave_setup();
	cc1100_cfg_gdo0(CC1100_GDOx_SYNC_WORD);

	cc1100_cmd_idle();
	cc1100_cmd_flush_rx();
	cc1100_cmd_calibrate();
	cc1100_cmd_rx();

	while(get_gdoa() == false)
	{
		OSTimeDlyHMSM(0,0,0,1);
		if(++cnt_wait_syn_ack > 50)
		return 0;
	}

	while(1)
	{
		if(get_gdoa() == false)
		{
			if((cc1100_status_crc_lqi() & 0x80))
			{

				length = rx_fifo_read(data,rssi,lqi);
				return length;
			}
			break;
		}
		OSTimeDlyHMSM(0,0,0,1);
	}

	return 0;
}


#endif


void cc1101_tx_carrier(void)
{

	cc1101_carrier_wave_setup();

	cc1100_cfg_txoff_mode(CC1100_TXOFF_MODE_STAY_TX);
	cc1100_cfg_manchester_en(CC1100_MANCHESTER_DISABLE);
	cc1100_write_reg(CC1100_REG_MDMCFG3,0x33);
	cc1100_cfg_mod_format(CC1100_MODULATION_ASK);
	cc1100_write_reg(CC1100_REG_FREND0,0x10);
	cc1100_cfg_gdo0(CC1100_GDOx_CLK_XOSC_1);

	/* IDLE */
	cc1100_cmd_idle();
	/* MANCAL*/
	cc1100_cmd_calibrate();
	/* FS WAKEUP */
	cc1100_cmd_flush_tx();

	cc1100_cfg_gdo0(0x0e);
	//carrier_sense();

	cc1100_cmd_tx();
}


void temperature_test_enable(void)
{
	cc1100_cmd_idle();
	cc1100_write_reg(CC1100_REG_PTEST,0xBF);
	cc1100_cfg_gdo0(0x80);
}


void temperature_test_disenable(void)
{
	cc1100_cfg_gdo0(0x3F);
	cc1100_write_reg(CC1100_REG_PTEST,0x7F);
}




bool rf_sync_device(u32 id)
{
	sync_t sync;
	int length;
	u8 rssi,lqi;
	u32 Os_GetTime=0;
	

	rf_lock();	
	sync.hdr.slave_id = id;
	sync.hdr.payload = PAYLOAD_SYNC;
	
	// download setup data
	
	set_freq();
	cc1101_tx(&sync,sizeof(sync_t),1);
	
	Os_GetTime = OSTimeGet() + RF_TIME_OUT * OS_TICKS_PER_SEC;
	
	
	while(1)
	{
		
		length = cc1101_rx((u8 *)&sync,&rssi,&lqi);
		if(length > 0 )
		{
			if(sync.hdr.slave_id == id && sync.hdr.payload == PAYLOAD_SYNC)
			{
				rf_unlock();
				return true;
			}
		}
		cc1100_cmd_idle();
		
		if(Os_GetTime <= OSTimeGet())
		{
			break;
		}
	}
	
	
	rf_unlock();
	
	return false;
}



bool rf_init_device(void)
{
	if(gEnv.use.driver == true)
	{
		if(rf_sync_device(gEnv.id.driver) == false)
		{
			return false;			
		}
	}
	
	if(gEnv.use.security == true)
	{
		if(rf_sync_device(gEnv.id.security) == false)
		{
			return false;
		}
	}

	if(gEnv.use.b_door == true)
	{
		if(rf_sync_device(gEnv.id.b_door) == false)
		{
			return false;
		}
	}
	
	if(gEnv.use.s_door == true)
	{
		if(rf_sync_device(gEnv.id.s_door) == false)
		{
			return false;
		}
	}
	
	if(gEnv.use.cabin_left == true)
	{
		if(rf_sync_device(gEnv.id.cabin_left) == false)
		{
			return false;
		}
	}
	if(gEnv.use.cabin_right == true)
	{
		if(rf_sync_device(gEnv.id.cabin_right) == false)
		{
			return false;
		}
	}

}


bool rf_state_device(u32 id,u8 state)
{
	set_t set;
	int length;
	u8 rssi,lqi;
	u32 Os_GetTime=0;
	

	rf_lock();
	
	set.hdr.slave_id = id;
	set.hdr.payload = SET_STATE;
	set.set = state;
	
	set_freq();
	cc1101_tx(&set,sizeof(set_t),1);
	
	Os_GetTime = OSTimeGet() + RF_TIME_OUT * OS_TICKS_PER_SEC;
	
	while(1)
	{
		
		set_freq();
		length = cc1101_rx((u8 *)&set,&rssi,&lqi);
		if(length > 0 )
		{
			if(set.hdr.slave_id == id && set.hdr.payload == SET_STATE)
			{
				rf_unlock();
				return true;
			}
		}
		cc1100_cmd_idle();
		
		if(Os_GetTime <= OSTimeGet())
		{
			break;
		}
		
	}
	
	
	rf_unlock();	
	return false;
}


bool rf_send_state(u8 state)
{
	bool ret = true;
	
	if(gEnv.use.driver == true)
	{
		if(rf_state_device(gEnv.id.driver,state) == false)
		{
			ret = false;
		}
	}
	
	if(gEnv.use.security == true)
	{
		if(rf_state_device(gEnv.id.security,state) == false)
		{
			ret = false;
		}
	}

	if(gEnv.use.b_door == true)
	{
		if(rf_state_device(gEnv.id.b_door,state) == false)
		{
			ret = false;
		}
	}
	
	if(gEnv.use.s_door == true)
	{
		if(rf_state_device(gEnv.id.s_door,state) == false)
		{
			ret = false;
		}
	}
	
	if(gEnv.use.cabin_left == true)
	{
		if(rf_state_device(gEnv.id.cabin_left,state) == false)
		{
			ret = false;
		}
	}
	if(gEnv.use.cabin_right == true)
	{
		if(rf_state_device(gEnv.id.cabin_right,state) == false)
		{
			ret = false;
		}
	}
	
	return ret;
}



bool rf_emg_device(u32 id,u8 emg)
{
	emg_t temg;
	int length;
	u8 rssi,lqi;
	u32 Os_GetTime=0;

	rf_lock();
	temg.hdr.slave_id = id;
	temg.hdr.payload = PAYLOAD_EMG;
	temg.emg = emg;
	
	set_freq();
	cc1101_tx(&temg,sizeof(emg_t),1);
	
	Os_GetTime = OSTimeGet() + RF_TIME_OUT * OS_TICKS_PER_SEC;
	
	
	while(1)
	{
		
		length = cc1101_rx((u8 *)&temg,&rssi,&lqi);
		if(length > 0 )
		{
			if(temg.hdr.slave_id == id && temg.hdr.payload == PAYLOAD_EMG)
			{
				rf_unlock();
				return true;
			}
		}
		cc1100_cmd_idle();

		if(Os_GetTime <= OSTimeGet())
		{
			break;
		}
	}
	
	
	rf_unlock();	
	return false;
}


bool rf_send_emg(u8 emg)
{
	bool ret = true;
	
	if(gEnv.use.driver == true)
	{
		if(rf_emg_device(gEnv.id.driver,emg) == false)
		{
			ret = false;
		}
	}
	
	if(gEnv.use.security == true)
	{
		if(rf_emg_device(gEnv.id.security,emg) == false)
		{
			ret = false;
		}
	}
	
	return ret;
}



packet_t gPacket;

void RFRecvTask(void *p_arg)
{
	u8 rssi,lpi;
	int length;
	
	
	#if 1
	
	while(1)
	{
		
	if(rf_init_device() == false)
	{
		// sound error message
		#if 0
		while(1);
		{
			OSTimeDlyHMSM(0,0,1,0);
		}
		#endif
	}
	}
	#endif

	while(1)
	{
		
		if(old_radio_mode!=radio_mode)
		{
			old_radio_mode = radio_mode;
		}

		
		if(radio_mode==RF_NOMAL_MODE)
		{		
			
			#if 1
			rf_lock();
			set_freq();
			length = cc1101_rx((u8 *)&gPacket,&rssi,&lpi);
			
			if(length == sizeof(packet_t))
			{
				if(gPacket.hdr.master_id = gEnv.id.main)						
				{
					// remocon async
					switch(gPacket.hdr.payload)				
					{
						case PAYLOAD_DOOR_OPEN_CMD:
						{
							door_open_t * open;
							
							open = (door_open_t *)&gPacket;
							
							oper_insert(OPER_RF_DOOR,open->door);
							break;
						}
						
						case PAYLOAD_SET_CMD:
						{
							
							set_cmd_t * set;
							
							set = (set_cmd_t *)&gPacket;
							
							if(set->set == true)
								oper_insert(OPER_RF_SET,1);
							else
								oper_insert(OPER_RF_RESET,1);
							break;
						}
						
						case PAYLOAD_REMOCON_EMG:
						{
							remote_emg_t * emg;
							
							emg = (remote_emg_t *)&gPacket;
							
							#if 0
							if(set->set == true)
							oper_insert(OPER_RF_SET,1);
							else
							oper_insert(OPER_RF_RESET,1);
							#endif 
							
							break;
						}
					}
				}
			}
			rf_unlock();
			
			#endif
		}
		else if(radio_mode==RF_TEST_CARRIER || radio_mode==RF_TEST_MODURATION || radio_mode==RF_TEST_ADJ_FREQ)
		{
			cc1100_cmd_idle();
			OSTimeDlyHMSM(0,0,1,0);			
			
			if(radio_mode==RF_TEST_CARRIER)
			{

			}
			else if(radio_mode==RF_TEST_MODURATION)
			{

				test_wave_mode();				
			}
			else if(radio_mode==RF_TEST_ADJ_FREQ)
			{
				//setup_oper();			
			}
		}
	}
}


void test_wave_mode(void)
{
	int i;
	int old,new;


	cc1100_cfg_gdo0(CC1100_GDOx_SYNC_WORD);
	cc1101_init_reg();
	cc1101_8PATABLE_write_reg();
	cc1100_cfg_gdo0(CC1100_GDOx_SYNC_WORD);


	while(1)
	{

		set_freq();
		cc1100_cmd_idle();

		OSTimeDlyHMSM(0,0,0,100);


		cc1101_rtx_reg_set(0); // tx
		cc1100_write_reg(CC1100_REG_PKTCTRL0,0x22);	//random TX mode
		cc1101_carrier_wave_setup();
		cc1100_cmd_idle();
		cc1100_cmd_calibrate();
		cc1100_cmd_tx();



		
		OSTimeDlyHMSM(0,0,3,0);
		cc1100_cmd_idle();
		OSTimeDlyHMSM(0,0,3,0);

	}
}




#if 0

u8 setup_oper(void)
{
	u8	ret;
	u8 rssi,lpi;
	int length;

	adjust_t * p_adjust_data;
	
	
	p_adjust_data = &adjust_data;

	
	while(1)
	{
		OSTimeDlyHMSM(0,0,3,0);
		adjust_data_preset(p_adjust_data);
		set_freq();
		ret = cc1101_tx((u8 *)p_adjust_data,sizeof(adjust_t),0);
		
		if(ret == 1)
		{
			//length = cc1101_rx((u8 *)adjust_t,0);
			length = cc1101_rx((u8 *)&p_adjust_data,&rssi,&lpi);
			if(length > 0)
			{
				//gggLength = length;
				if((length - 2) == sizeof(adjust_t) && p_adjust_data->hdr.payload == PAYLOAD_ADJUST_WRITE)
				{


					#if 0
					memcpy((u8 *)&gEnv.id.main,(u8 *)&p_adjust_data->f_option.env_data[0],4);
					

					gTele_env.ctl_data.adj_freq		=	p_adjust_data->f_option.env_data[4];
					gTele_env.ctl_data.freq_add_sub =	p_adjust_data->f_option.env_data[5];
					gTele_env.ctl_data.adj_temper	=	p_adjust_data->f_option.env_data[6];
					gTele_env.ctl_data.temper_add_sub =	p_adjust_data->f_option.env_data[7];

					
					hex_change_level(p_adjust_data->f_option.level);
					#endif
					tele_env_save(&gTele_env);
					env_save(&gEnv);
					
					
					
					cc1101_tx_carrier();
					OSTimeDlyHMSM(0,0,5,0);
					return 1;
				}
			}
		}
	}
}



#endif
